#!/usr/bin/python3
import os
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad

# Get the files from the directory we are in (Sandbox implementation)
def getFilesRecursively():
	files_to_infect = []
	for dirs, subs, files in os.walk(os.getcwd()):
		for file in files:
			files_to_infect.append(dirs + '/' + file)
	return files_to_infect

# decryptor function
def decrypt(file, data, key, iv):
	cipher = AES.new(key, AES.MODE_CBC, iv)
	plaintext = unpad(cipher.decrypt(data), 16)
	with open(file, 'wb') as encryption_handle:
		encryption_handle.write(plaintext)

# Validation check. We don't want to try to decrypt our encryptor or decryptor
def validation(data):
	if b"#######################ENCRYPTOR########################" in data:
		return False
	elif b"#######################DECRYPTOR########################" in data:
		return False
	return True
	
# Load the keys generated from the encryptor to decrypt
def load():
	with open(f"{os.path.expanduser('~')}/Desktop/keys", 'rb') as keyhandle:
		alld = keyhandle.read()
		# The key is 32 bytes, so the first 32 bytes of the file is our key sequence and the rest 16 is the IV
		key = alld[:32]
		iv = alld[32:]
		return key,iv

# Load the key and iv from the file
key, iv = load()

# Get all files recursively and decrypt
for file in getFilesRecursively():
	# Get the file contents for validation sake
	with open(file, 'rb') as encryptor_handle:
		data = encryptor_handle.read()
	# If it's our encryptor or decryptor STOP!
	if not validation(data):
		continue
	# decrypt the contents
	decrypt(file, data, key, iv)



#######################DECRYPTOR########################